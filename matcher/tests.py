#!/usr/bin/python3
# -*- coding: utf-8 -*-

'''
Created on 4 Dec 2019

@author: atilante
'''
import copy
import unittest
from buildheap import BuildHeapMatcher
from dtw import dtw

class TestBuildHeapMatcher(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.matcher = BuildHeapMatcher()

    def states_from_swaps(self, input, swaps):
        """Helper method which creates a sequence of states from input and
        swaps.

        Parameters:
        input (list of integers): a heap array
        swaps (list of tuples): each tuple is (x, y, ...), where x and y are
                                the indices of the swap, and the rest is
                                optional (such as with testing the Delayed
                                recursion algorithm variants)

        Returns:
        list of tuples: each tuple is a state of the heap array. There are
        len(swaps) + 1 states, and the first one is the input."""

        states = [tuple(input)]
        A = copy.copy(input)
        for s in swaps:
            A[s[0]], A[s[1]] = A[s[1]], A[s[0]]
            states.append(tuple(A))
        return states

    def swap_indices(self, S, i, j):
        S[i], S[j] = S[j], S[i]

    def test_states_and_swaps(self):
        """Self-test: states_from_swaps() helper method"""
        input = [14, 17, 13, 15, 16, 12, 11, 19, 18, 10]
        swaps = [(4, 9), (2, 6), (1, 4), (4, 9), (0, 1)]
        expected_states = [
            # 0   1   2   3   4   5   6   7   8   9
            (14, 17, 13, 15, 16, 12, 11, 19, 18, 10),
            (14, 17, 13, 15, 10, 12, 11, 19, 18, 16),
            (14, 17, 11, 15, 10, 12, 13, 19, 18, 16),
            (14, 10, 11, 15, 17, 12, 13, 19, 18, 16),
            (14, 10, 11, 15, 16, 12, 13, 19, 18, 17),
            (10, 14, 11, 15, 16, 12, 13, 19, 18, 17)
            ]
        states = self.states_from_swaps(input, swaps)
        self.assertListEqual(states, expected_states)

    def test_compute_level_indices(self):
        """Tests compute_level_indices()."""
        m = self.__class__.matcher

        test_heap_sizes = [10, 15, 100]
        expected_results = [
            [(0, 0), (1, 2), (3, 6), (7, 9)],
            [(0, 0), (1, 2), (3, 6), (7, 14)],
            [(0, 0), (1, 2), (3, 6), (7, 14), (15, 30), (31, 62), (63, 99)]
            ]

        for i in range(len(test_heap_sizes)):
            size = test_heap_sizes[i]
            expected = expected_results[i]
            m.compute_level_indices(size)
            self.assertEqual(m.assumed_heap_size, size)
            self.assertListEqual(m.heap_levels, expected)

    def test_parse_recording(self):
        """Tests a Build-heap recording parsed from JSON generated by the
        JSAV exercise."""

        recording = []
        input = [14, 17, 13, 15, 16, 12, 11, 19, 18, 10]
        A = copy.copy(input)
        swaps = [(4, 9), (2, 6), (1, 4), (4, 9), (0, 1)]
        states = []

        recording.append({
            'ind': [{'v': x} for x in A],
            'style': 'height: 60px; width: 301px;',
            'classes': ['jsavcenter'] })
        states.append(tuple(A))

        for s in swaps:
            A[s[0]], A[s[1]] = A[s[1]], A[s[0]]
            recording.append({
              'ind': [{'v': x} for x in A],
              'style': 'height: 60px; width: 301px;',
              'classes': ['jsavcenter'] })
            states.append(tuple(A))

        m = self.__class__.matcher

        (result_input,
        result_states,
        result_swaps) = m.parse_recording(recording)

        self.assertListEqual(input, result_input)
        self.assertListEqual(states, result_states)
        self.assertListEqual(swaps, result_swaps)

    def test_choose_class(self):
        """Tests choose_class()"""

        m = self.__class__.matcher
        self.assertEqual(m.choose_class([0]), 0)
        self.assertEqual(m.choose_class([365]), 365)

        # 100 (Correct) has highest preference
        self.assertEqual(m.choose_class([200, 100, 101]), 100)

        # No 100. 400 has the highest preference.
        self.assertEqual(m.choose_class([206, 400, 300]), 400)

        # 103 is not in the preference list but 300 and 301 are.
        self.assertEqual(m.choose_class([301, 103, 300]), 300)

        # None of the codes is in the preference list. Choose lowest code.
        self.assertEqual(m.choose_class([602, 103, 804]), 103)




    def test_state_similarity(self):
        """Tests state_similarity()"""

        sim = self.__class__.matcher.state_similarity

        # candidate sequence
        candidate = [(1, 2, 3), (3, 1, 2), (2, 1, 3)]

        # Empty candidate or student's sequence should result in 0
        self.assertEqual(sim(candidate, []), 0)
        self.assertEqual(sim([], candidate), 0)

        # Identical sequences should result in length of the sequence
        self.assertEqual(sim(candidate, candidate), len(candidate))

        # If only the first state is the same, the result should be 1
        student = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
        self.assertEqual(sim(candidate, student), 1)

        # Two matching states from the beginning
        student = [candidate[0], candidate[1], (2, 2, 2)]
        self.assertEqual(sim(candidate, student), 2)

        # Two matching, one mismatch, one match
        student.append(candidate[2])
        self.assertEqual(sim(candidate, student), 4)

        # One duplicate state in student's sequence should be counted only once
        # (Also: maximum return value is the length of the shorter sequence)
        student = [candidate[0], candidate[1], candidate[2], candidate[2]]
        self.assertEqual(sim(candidate, student), 3)

        # One missing state in student's sequence
        # (Also: maximum return value is the length of the shorter sequence)
        student = [candidate[0], candidate[1]]
        self.assertEqual(sim(candidate, student), 2)

        # Wrong order of states: number of furthest match still reported
        student = [candidate[0], candidate[2], candidate[1]]
        self.assertEqual(sim(candidate, student), 3)

        # Example in Artturi's master's thesis
        self.assertEqual(sim("ABDEFG", "ABCDG"), 5)
        self.assertEqual(sim("ABCDG", "ABDEFG"), 6)

        # Another example in Artturi's master's thesis
        self.assertEqual(sim("ABDEFGHI", "ABCDGJK"), 5)
        self.assertEqual(sim("ABCDGJK", "ABDEFGHI"), 6)


    def test_lcs(self):

        lcs = self.__class__.matcher.lcs

        sim, matches = lcs("ABCBDAB", "BDCABA")

        # 0 1 2 3 4 5 6 7
        # A B C B D A B
        #  /  |  \  |
        # B D C A B A

        self.assertEqual(sim, 4)
        self.assertListEqual(matches, [(1,0), (2,2), (3,4), (5,5)])

    def test_lcs_similarity(self):

        lcs = self.__class__.matcher.lcs_similarity

        # Example from:
        # Cormen, Leiserson, Rivest, Stein: Introduction to Algorithms (3rd ed.).
        # MIT Press 2009. ISBN 9780262270830. Page 395.
        self.assertEqual(lcs("ABCBDAB", "BDCABA"), 4)

        # The same example with tuples
        self.assertEqual(lcs(
            [(0, 1), (2, 3), (4, 5), (2, 3), (6, 7), (0, 1), (2, 3)],
            [(2, 3), (6, 7), (4, 5), (0, 1), (2, 3), (0, 1)]), 4)

        # Zero cases
        self.assertEqual(lcs([], []), 0)
        self.assertEqual(lcs([(1, 0)], []), 0)
        self.assertEqual(lcs([], [(0, 1)]), 0)

        # One missing element
        self.assertEqual(lcs([(4, 9), (2, 6), (1, 4), (4, 9), (0, 1)],
                             [(4, 9), (2, 6), (1, 4), (0, 1)]), 4)

        # One differing element at equal index
        self.assertEqual(lcs([(4, 9), (2, 6), (1, 4), (4, 9), (0, 1)],
                             [(4, 9), (2, 6), (1, 4), (4, 8), (0, 1)]), 4)

        # One differing element at different index
        self.assertEqual(lcs([(4, 9), (2, 6), (1, 4), (4, 9), (0, 1)],
                             [(4, 9), (2, 6), (4, 8), (1, 4), (0, 1)]), 4)

        # All elements same but one in different position
        self.assertEqual(lcs([(4, 9), (2, 6), (1, 4), (4, 9), (0, 1)],
                             [(4, 9), (2, 6), (4, 9), (1, 4), (0, 1)]), 4)


    def test_Correct_Correct(self):
        """Correct loop, correct heapify"""

        #              14                      14                      14
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       17         13           17        (13)          (17)       11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 12  11     15       10  12 (11)    15      (10) 12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (10)             19  18  16              19  18  16
        #
        #              14                     (14)                    10
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      10          11          (10)        11           14         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (17) 12  13     15       16  12  13     15       16  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (16)             19  18  17              19  18  17
        #

        input = [14, 17, 13, 15, 16, 12, 11, 19, 18, 10]
        swaps = [(4, 9), (2, 6), (1, 4), (4, 9), (0, 1)] # heap array indices

        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        heapify = m.min_heapify        # Correct

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)

        self.assertListEqual(swaps, actual_swaps)


    def test_Correct_Delayed_recursion(self):
        """Correct loop, heapify with delayed recursion """

        # Correct variant: there is one recursive swap, the fourth swap (4,9).
        #
        #              14                      14                      14
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       17         13           17        (13)          (17)       11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 12  11     15       10  12 (11)    15      (10) 12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (10)             19  18  16              19  18  16
        #
        #              14                     (14)                     10
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      10          11          (10)        11           14         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (17) 12  13     15       16  12  13     15       16  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (16)             19  18  17              19  18  17
        #
        # Delayed recursion: fourth swap (4,9) is the fifth swap.
        # Invalid variants: fourth swap (4,9) is the second or third swap.

        input = [14, 17, 13, 15, 16, 12, 11, 19, 18, 10]

        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct

        A = list(input)
        states = []
        swaps = []
        for i in main_loop:
            m.delayed_recursion(A, i, states, swaps)


        swaps_expected = [(4, 9, False), (2, 6, False), (1, 4, False),
            (4, 9, True), (0, 1, False)]
        self.assertListEqual(swaps, swaps_expected)



    def test_Correct_Delayed_recursion_similarity(self):
        # The same input as in test_Correct_Delayed_recursion()

        # Correct variant: there is one recursive swap, the fourth swap (4,9).
        #
        #              14                      14                      14
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       17         13           17        (13)          (17)       11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 12  11     15       10  12 (11)    15      (10) 12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (10)             19  18  16              19  18  16
        #
        #              14                     (14)                    10
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      10          11          (10)        11           14         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (17) 12  13     15       16  12  13     15       16  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (16)             19  18  17              19  18  17

        input = [14, 17, 13, 15, 16, 12, 11, 19, 18, 10]

        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct

        # C_swaps are the "candidate swaps"; it imitates a swap sequence with
        # recursion information as BuildHeapMatcher.delayed_recursion() would
        # have produced it.
        C_swaps  = [(4, 9, False), (2, 6, False), (1, 4, False),
            (4, 9, True), (0, 1, False)]

        #
        # The following tests are similar to test_state_similarity().
        #
        S_swaps = [s[0:2] for s in C_swaps]

        # Identical sequences should result in 0, because order is the same and
        # thus this is not delayed recursion.
        self.assertEqual(m.lcs_similarity_delayed_recursion(
            C_swaps, S_swaps), 0)

        # Empty candidate or student's sequence should result in 0
        self.assertEqual(m.lcs_similarity_delayed_recursion(
            C_swaps, []), 0)
        self.assertEqual(m.lcs_similarity_delayed_recursion(
            [], S_swaps), 0)


        # TODO: actual delayed recursion example, maximum number of recursive
        # swaps with heap size of 10.

        #              19                      19                      19
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       18         17           18         17           18        (17)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   16      (15) 14  13    (16)      10  14  13     11       10  14 (13)
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 12  11 (10)             12 (11) 15              12  16  15
        #
        #              19                      19                     (19)
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      (18)        13           10         13          (10)        13
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   11      (10) 14  17     11      (18) 14  17     11       15  14  17
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 12  16  15              12  16 (15)             12  16  18
        #
        #              10                      10                      10
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      (19)        13           11         13           11         13
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (11)      15  14  17    (19)      15  14  17     12       15  14  17
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 12  16  18             (12) 16  18              19  16  18

        input = [i for i in range(19, 9, -1)]
        C_swaps  = [(4, 9, False), (3, 8, False), (2, 6, False), # 0-2
                      (1, 4, False), (4, 9, True), (0, 1, False),  # 3-5
                      (1, 3, True), (3, 7, True)]                  # 6,7

        S_swaps = [s[0:2] for s in C_swaps]

        # Legal delayed recursion swaps
        swaps_delayed = [
            # correct order:[(4, 9), (0, 1), (1, 3), (3, 7)]
            S_swaps[0:4] + [(4, 9), (0, 1), (3, 7), (1, 3)],
            S_swaps[0:4] + [(0, 1), (4, 9), (1, 3), (3, 7)],
            S_swaps[0:4] + [(0, 1), (4, 9), (3, 7), (1, 3)],
            S_swaps[0:4] + [(0, 1), (1, 3), (4, 9), (3, 7)],
            S_swaps[0:4] + [(0, 1), (3, 7), (4, 9), (1, 3)],
            S_swaps[0:4] + [(0, 1), (1, 3), (3, 7), (4, 9)],
            S_swaps[0:4] + [(0, 1), (3, 7), (1, 3), (4, 9)]]

        similarities = []
        for s in swaps_delayed:
            similarities.append(m.lcs_similarity_delayed_recursion(C_swaps, s))
        self.assertEqual(similarities, [8] * len(swaps_delayed))

        # Illegal swaps: a recursive swap appears earlier than it should.
        # These will not be counted as recursive swaps.
        swaps_illegal = [
            # Recursive swap (4,9) at indices 1..3
            [(4, 9), (4, 9), (3, 8), (2, 6), (1, 4), (0, 1), (1, 3), (3, 7)],
            [(4, 9), (3, 8), (4, 9), (2, 6), (1, 4), (0, 1), (1, 3), (3, 7)],
            [(4, 9), (3, 8), (2, 6), (4, 9), (1, 4), (0, 1), (1, 3), (3, 7)],

            # Recursive swap (1,3) at indices 0..5
            [(1, 3), (4, 9), (3, 8), (2, 6), (1, 4), (4, 9), (0, 1), (3, 7)],
            [(4, 9), (1, 3), (3, 8), (2, 6), (1, 4), (4, 9), (0, 1), (3, 7)],
            [(4, 9), (3, 8), (1, 3), (2, 6), (1, 4), (4, 9), (0, 1), (3, 7)],
            [(4, 9), (3, 8), (2, 6), (1, 3), (1, 4), (4, 9), (0, 1), (3, 7)],
            [(4, 9), (3, 8), (2, 6), (1, 4), (1, 3), (4, 9), (0, 1), (3, 7)],
            [(4, 9), (3, 8), (2, 6), (1, 4), (4, 9), (1, 3), (0, 1), (3, 7)]
            ]

        similarities = []
        for s in swaps_illegal:
            similarities.append(m.lcs_similarity_delayed_recursion(C_swaps, s))
        self.assertEqual(similarities, [0] * len(swaps_illegal))


    def test_Correct_NoRecursion(self):
        """Correct loop, no-recursion"""

        #              14                      14                      14
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       17         13           17        (13)          (17)       11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 12  11     15       10  12 (11)    15      (10) 12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (10)             19  18  16              19  18  16
        #
        #             (14)                     10
        #        ┌──────┴───┐            ┌──────┴───┐
        #      (10)        11           14         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15       17  12  13     15       17  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘S_swaps
        # 19  18  16              19  18  16
        #

        input = [14, 17, 13, 15, 16, 12, 11, 19, 18, 10]
        swaps = [(4, 9), (2, 6), (1, 4), (0, 1)] # heap array indices
        m = self.__class__.matcher
        main_loop = m.loop_variants[0][2] # Correct
        heapify = m.no_recursion          # No-Recursion

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)

        self.assertListEqual(swaps, actual_swaps)

    def test_Correct_heapify_with_father_lr(self):
        """Correct loop, Heapify-with-Father LR"""

        #              17                      17                      17
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       14         13           14        (13)          14        (12)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   16      (16) 12  11     16       15 (12) 11     16       15  13 (11)
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (15)             19  18  16              19  18  16
        #
        #             (17)                    (14)                    11
        #        ┌──────┴───┐            ┌──────┴───┐           ┌──────┴───┐
        #      (14)        11           17        (11)         17         14
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐     ┌───┴────┐   ┌─┴─┐
        #   16       15  13  12     16       15  12  13    16       15  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘           ┌─┴─┐   ┌──┘
        # 19  18  16              19  18  16             19  18  16
        #

        input = [17, 14, 13, 16, 16, 12, 11, 19, 18, 15]
        swaps = [(4, 9), (2, 5), (2, 6), (0, 1), (0, 2)] # heap array

        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        heapify = m.heapify_with_father_lr # Heapify-with-Father LR

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)

        self.assertListEqual(swaps, actual_swaps)

    def test_Correct_heapify_with_father_lr_recursive(self):
        """Correct loop, Heapify-with-Father LR recursive"""

        #              17                      17                      17
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       14         13           14        (13)          14        (12)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   16      (16) 12  11     16       15 (12) 11     16       15  13 (11)
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (15)             19  18  16              19  18  16
        #
        #             (17)                     14                     14
        #        ┌──────┴───┐            ┌──────┴───┐           ┌──────┴───┐
        #      (14)        11          (17)        11         (16)        11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐     ┌───┴────┐   ┌─┴─┐
        #   16       15  13  12    (16)      15  13  12    17      (15) 13  12
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘           ┌─┴─┐   ┌──┘
        # 19  18  16              19  18  16             19  18  16
        #
        #             (14)                     11                     11
        #        ┌──────┴───┐            ┌──────┴───┐           ┌──────┴───┐
        #       15        (11)          15        (14)         15        (13)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐     ┌───┴────┐   ┌─┴─┐
        #   17       16  13  12     17       16 (13) 12    17       16  14 (12)
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘           ┌─┴─┐   ┌──┘
        # 19  18  16              19  18  16             19  18  16
        #
        #              11
        #        ┌──────┴───┐
        #       15         12
        #    ┌───┴────┐   ┌─┴─┐
        #   17       16  14  13
        #  ┌─┴─┐   ┌──┘
        # 19  18  16

        input = [17, 14, 13, 16, 16, 12, 11, 19, 18, 15]
        swaps = [(4, 9), (2, 5), (2, 6), (0, 1), (1,3), (1,4), (0, 2), (2, 5),
                 (2, 6)] # heap array

        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        heapify = m.heapify_with_father_lr_recursive # Heapify-with-Father LR

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)

        self.assertListEqual(swaps, actual_swaps)


    def test_Correct_heapify_with_father_rl(self):
        """Correct loop, Heapify-with-Father RL"""

        #              14                      14                      14
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       17         13           17        (13)          17        (12)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 11  12     15       10  11 (12)    15       10 (11) 13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (10)             19  18  16              19  18  16
        #
        #              14                     (14)                   (11)
        #        ┌──────┴───┐            ┌──────┴───┐           ┌──────┴───┐
        #      (17)        11           10        (11)        (10)        14
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐     ┌───┴────┐   ┌─┴─┐
        #   15      (10) 12  13     15       17  12  13    15       17  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘           ┌─┴─┐   ┌──┘
        # 19  18  16              19  18  16             19  18  16
        #
        #              10
        #        ┌──────┴───┐
        #       11         14
        #    ┌───┴────┐   ┌─┴─┐
        #   15       17  12  13
        #  ┌─┴─┐   ┌──┘
        # 19  18  16

        input = [14, 17, 13, 15, 16, 11, 12, 19, 18, 10]
        swaps = [(4, 9), (2, 6), (2, 5), (1, 4), (0, 2), (0, 1)] # heap array

        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        heapify = m.heapify_with_father_rl # Heapify-with-Father RL

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)

        self.assertListEqual(swaps, actual_swaps)

    def test_Correct_heapify_with_father_rl_recursive(self):
        """Correct loop, Heapify-with-Father RL"""

        #              14                      14                      14
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       17         13           17        (13)          17        (12)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 11  12     15       10  11 (12)    15       10 (11) 13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (10)             19  18  16              19  18  16
        #
        #              14                      14                    (14)
        #        ┌──────┴───┐            ┌──────┴───┐           ┌──────┴───┐
        #      (17)        11           10         11          10        (11)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐     ┌───┴────┐   ┌─┴─┐
        #   15      (10) 12  13     15      (17) 12  13    15       16  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘           ┌─┴─┐   ┌──┘
        # 19  18  16              19  18 (16)            19  18  17
        #
        #              11                      11                    (11)
        #        ┌──────┴───┐            ┌──────┴───┐           ┌──────┴───┐
        #       10        (14)          10        (13)        (10)        12
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐     ┌───┴────┐   ┌─┴─┐
        #   15       16  12 (13)    15       16 (12) 14    15       16  14  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘           ┌─┴─┐   ┌──┘
        # 19  18  17              19  18  17             19  18  17
        #
        #              10
        #        ┌──────┴───┐
        #       11         12
        #    ┌───┴────┐   ┌─┴─┐
        #   15       16  14  13
        #  ┌─┴─┐   ┌──┘
        # 19  18  17



        input = [14, 17, 13, 15, 16, 11, 12, 19, 18, 10]
        swaps = [(4, 9), (2, 6), (2, 5), (1, 4), (4, 9), (0, 2), (2, 6),
                 (2, 5), (0, 1)]  # heap array indices

        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        heapify = m.heapify_with_father_rl_recursive

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)

        self.assertListEqual(swaps, actual_swaps)


    def test_Correct_heapify_up(self):
        """Correct loop, Heapify-Up"""

        #              14                      14                     (14)
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       17         13          (17)        13          (12)        13
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 18  10     15      (12) 18  10     15       17  18  10
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  11 (12)             19  18  16              19  18  16
        #
        #              12                      12                     (12)
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       14         13          (14)        13          (11)        13
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (15)      17  18  10    (11)      17  18  10     14       17  18  10
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19 (11) 16              19  15  16              19  15  16
        #
        #              11                     (11)                     10
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       12        (13)          12        (10)          12         10
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   14       17  18 (10)    14       17  18  13     14       17  18  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  15  16              19  15  16              19  15  16


        input = [14, 17, 13, 15, 16, 18, 10, 19, 11, 12]
        swaps = [(4, 9), (1, 4), (0, 1), (3, 8), (1, 3),  # heap array indices
                 (0, 1), (2, 6), (0, 2)]

        m = self.__class__.matcher
        main_loop = m.loop_variants[0][2]  # Correct
        heapify = m.heapify_up             # Heapify-Up

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)

        self.assertListEqual(swaps, actual_swaps)

    def test_Correct_max_heapify(self):
        """Correct loop, Max-Heapify"""

        #              10                      10                      10
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       12         11           12         11           12        (11)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (14) 16  13    (15)      18  16  10     19       18 (16) 13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  17 (18)            (19) 17  14              15  17  14
        #
        #              10                      10                     (10)
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      (12)        16           19         16          (19)        16
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (19)      18  11  13    (12)      18  11  13     17       18  11  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 15  17  14              15 (17) 14              15  12  14
        #
        #              19                      19                      19
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      (10)        16           18         16           18         16
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   17      (18) 11  13     17      (10) 11  13     17       14  11  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 15  12  14              15  12 (14)             15  12  10


        input = [10, 12, 11, 15, 14, 16, 13, 19, 17, 18]
        swaps = [(4, 9), (3, 7), (2, 5), (1, 3), (3, 8),  # heap array indices
                 (0, 1), (1, 4), (4, 9)]

        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        heapify = m.max_heapify        # Max-Heapify

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)

        self.assertListEqual(swaps, actual_swaps)

    def test_Correct_wrong_duplicate(self):
        """Correct loop, Wrong-duplicate"""

        #              19                      19                      19
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       13         16           13         16           13        (16)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (12) 11  10    (15)      10  11  10     10       10  11 (10)
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 10  10 (10)             10 (10) 12              10  15  12
        #
        #              19                      19                     (19)
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      (13)        10           10         10           10        (10)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   10      (10) 11  16     10      (13) 11  16     10       10  11  16
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 10  15  12              10  15 (12)             10  15  13
        #
        #              10                      10
        #        ┌──────┴───┐            ┌──────┴───┐
        #       10        (19)          10         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   10       10 (11) 16     10       10  19  16
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 10  15  12              10  15  12


        input = [19, 13, 16, 15, 12, 11, 10, 10, 10, 10]
        swaps = [(4, 9), (3, 8), (2, 6), (1, 4),  # heap array indices
                 (4, 9), (0, 2), (2, 5)]

        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        heapify = m.wrong_duplicate       # Max-Heapify

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)

        self.assertListEqual(swaps, actual_swaps)

    def test_Correct_path_bubblesort(self):
        """Correct loop, Path-bubblesort"""

        #              14                      14                     (14)
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       17         13          (17)        13          (12)        13
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 18  11     15      (12) 18  11     15       17  18  11
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  10 (12)             19  10  16              19  10  16
        #
        #
        #              12                      12                      12
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       14         13           14         13          (14)        13
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (17) 18  11    (15)      16  18  11    (10)      16  18  11
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  10 (16)             19 (10) 17              19  15  17
        #
        #             (12)                     10                      10
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      (10)        13           12        (13)          12         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   14       16  18  11     14       16  18 (11)    14       16  18  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  15  17              19  15  17              19  15  17

        input = [14, 17, 13, 15, 16, 18, 11, 19, 10, 12]
        swaps = [(4, 9), (1, 4), (0, 1), (4, 9), (3, 8),  # heap array indices
                 (1, 3), (0, 1), (2, 6)]

        m = self.__class__.matcher
        main_loop = m.loop_variants[0][2]  # Correct
        heapify = m.path_bubblesort       # Path-Bubblesort

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)

        self.assertListEqual(swaps, actual_swaps)

    #
    # Main loop variants
    #

    def test_Zigzag_RL(self):
        """Loop: Zigzag RL, correct Heapify"""

        #              14                      14                      14
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       17         13           17         13          (17)        13
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 18  11    (15)      12  18  11    (10)      12  18  11
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  10 (12)             19 (10) 16              19  15  16
        #
        #              14                      14                     (14)
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       10         13           10        (13)         (10)        11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (17)      12  18  11     15       12  18 (11)    15       12  18  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19 (15) 16              19  17  16              19  17  16
        #
        #              10                      14
        #        ┌──────┴───┐            ┌──────┴───┐
        #      (14)        11           12         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (12) 18  13     15       14  18  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  17  16              19  17  16

        input = [14, 17, 13, 15, 16, 18, 11, 19, 10, 12]
        swaps = [(4, 9), (3, 8), (1, 3), (3, 8), (2, 6),  # heap array indices
                 (0, 1), (1, 4)]

        m = self.__class__.matcher
        main_loop = m.loop_variants[1][2]  # Zigzag RL
        heapify = m.min_heapify            # Correct heapify

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)

        self.assertListEqual(swaps, actual_swaps)

    def test_Zigzag_LR(self):
        """Loop: Zigzag LR, correct Heapify"""

        #              14                      14                      14
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       17         13           17         13           17        (13)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (15)      16  18  11     10      (16) 18  11     10       12  18 (11)
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19 (10) 12              19  15 (12)             19  15  16
        #
        #              14                      14                     (14)
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      (17)        11           10         11          (10)        11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (10)      12  18  13    (17)      12  18  13     15       12  18  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  15  16              19 (15) 16              19  17  16
        #
        #              10                      10
        #        ┌──────┴───┐            ┌──────┴───┐
        #      (14)        11           12         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (12) 18  13     15       14  18  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  17  16              19  17  16

        input = [14, 17, 13, 15, 16, 18, 11, 19, 10, 12]
        swaps = [(3, 8), (4, 9), (2, 6), (1, 3), (3, 8),  # heap array indices
                 (0, 1), (1, 4)]

        m = self.__class__.matcher
        main_loop = m.loop_variants[2][2]  # Zigzag LR
        heapify = m.min_heapify            # Correct heapify

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)

        self.assertListEqual(swaps, actual_swaps)

    def test_Level_LR(self):
        """Loop: Level LR, correct Heapify"""

        #              14                      14                      14
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       17         13           17         13          (17)        13
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (15)      16  18  11     10      (16) 18  11    (10)      12  18  11
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19 (10) 12              19  15 (12)             19  15  16
        #
        #              14                      14                     (14)
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       10         13           10        (13)         (10)        11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (17)      12  18  11     15       12  18 (11)    15       12  18  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19 (15) 16              19  17  16              19  17  16
        #
        #              10                      10
        #        ┌──────┴───┐            ┌──────┴───┐
        #      (14)        11           12         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (12) 18  13     15       14  18  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  17  16              19  17  16

        input = [14, 17, 13, 15, 16, 18, 11, 19, 10, 12]
        swaps = [(3, 8), (4, 9), (1, 3), (3, 8), (2, 6),  # heap array indices
                 (0, 1), (1, 4)]

        m = self.__class__.matcher
        main_loop = m.loop_variants[3][2]  # Zigzag LR
        heapify = m.min_heapify            # Correct heapify

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)

        self.assertListEqual(swaps, actual_swaps)

    def test_Top_down(self):
        """Loop: Top-down, correct Heapify"""

        # It is not possible to produce an input which would make heapify
        # act on each index. This first input causes heapify to swap elements
        # at main loop indices 0, 1, 2, and 4.

        #             (19)                     17                      17
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      (17)        18          (19)        18           15         18
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15       16  13  14    (15)      16  13  14    (19)      16  13  14
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  10  12              11  10  12              11 (10) 12
        #
        #              17                      17                    17
        #        ┌──────┴───┐            ┌──────┴───┐          ┌──────┴───┐
        #      (15)        18           10         18         10        (18)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐    ┌───┴────┐   ┌─┴─┐
        #  (10)      16  13  14    (15)      16  13  14   11       16 (13) 14
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘          ┌─┴─┐   ┌──┘
        # 11  19  12             (11) 19  12            15  19  12
        #
        #              17                      17
        #        ┌──────┴───┐            ┌──────┴───┐
        #       10         13           10         13
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   11      (16) 18  14     11       12  18  14
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 15  19 (12)             15  19  16

        input = [19, 17, 18, 15, 16, 13, 14, 11, 10, 12]
        swaps = [(0, 1), (1, 3), (3, 8), (1, 3), (3, 7),  # heap array indices
                 (2, 5), (4, 9)]

        m = self.__class__.matcher
        main_loop = m.loop_variants[4][2]  # Top-down
        heapify = m.min_heapify            # Correct heapify

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        self.assertListEqual(swaps, actual_swaps)

        # This second input causes heapify to swap elements at main loop indices
        # 0, 2, 3, 4.
        #
        #             (19)                     17                      17
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      (17)        18           19        (18)          19         13
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   20       21  13  14     20       21 (13) 14    (20)      21  18  14
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  10  12              11  10  12              11 (10) 12
        #
        #              17                      17
        #        ┌──────┴───┐            ┌──────┴───┐
        #       19         13           19         13
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   10      (21) 18  14     10       12  18  14
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  20 (12)             11  20  21

        input = [19, 17, 18, 20, 21, 13, 14, 11, 10, 12]
        swaps = [(0, 1), (2, 5), (3, 8), (4, 9)]  # heap array indices
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        self.assertListEqual(swaps, actual_swaps)

    def test_Zigzag_Top_down_LR(self):
        """Loop: Zigzag Top-down LR, No-Recursion"""

        # No-Recursion heapify is used here to make testing of the zigzag
        # iteration easier.
        #
        #             (11)                     10                      10
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       15        (10)         (15)        11           12        (11)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   12       16   3   4    (12)      16   3   4     15       16  (3)  4
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  10   9              11  10   9              11  10   9
        #
        #              10                      10                      10
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       12          3           12          3           12          3
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 11   4    (15)       9  11   4     10        9  11   4
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  10  (9)             11 (10) 16              11  15  16

        input = [11, 15, 10, 12, 16, 3, 4, 11, 10, 9]
        swaps = [(0, 2), (1, 3), (2, 5), (4, 9), (3, 8)] # heap array indices

        m = self.__class__.matcher
        main_loop = m.loop_variants[5][2]
        heapify = m.no_recursion

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        self.assertListEqual(swaps, actual_swaps)

    def test_Zigzag_Top_down_RL(self):
        """Loop: Zigzag Top-down RL, No-Recursion"""

        # No-Recursion heapify is used here to make testing of the zigzag
        # iteration easier.
        #
        #             (11)                     10                      10
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       15        (10)          15        (11)         (15)         3
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   12       16   3   4     12       16  (3)  4    (12)      16  11   4
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  10   9              11  10   9              11  10   9
        #
        #              10                      10                      10
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       12          3           12          3           12          3
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 11   4    (15)       9  11   4     10        9  11   4
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  10  (9)             11 (10) 16              11  15  16

        input = [11, 15, 10, 12, 16, 3, 4, 11, 10, 9]
        swaps = [(0, 2), (2, 5), (1, 3), (4, 9), (3, 8)] # heap array indices

        m = self.__class__.matcher
        main_loop = m.loop_variants[6][2]
        heapify = m.no_recursion

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        self.assertListEqual(swaps, actual_swaps)

    def test_inorder(self):
        """Loop: Inorder, No-Recursion"""

        # No-Recursion heapify is used here to make testing easier.
        #
        #              13                      13                      13
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       15         10          (15)        10           10         10
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (12)      19   3   4    (10)      19   3   4     15      (19)  3   4
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11 (10) 16              11  12  16              11  12 (16)
        #
        #             (13)                     10                      10
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      (10)        10           13        (10)          13          3
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15       16   3   4     15       16  (3)  4     15       16  10   4
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  12  19              11  12  19              11  12  19


        input = [13, 15, 10, 12, 19, 3, 4, 11, 10, 16]
        swaps = [(3, 8), (1, 3), (4, 9), (0, 1), (2, 5)] # heap array indices

        m = self.__class__.matcher
        main_loop = m.loop_variants[7][2]
        heapify = m.no_recursion

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        self.assertListEqual(swaps, actual_swaps)

    def test_subtree_min_index(self):
        """Tests searching a minimun index in a subtree of a binary heap."""

        #              13
        #        ┌──────┴───┐
        #       15         10
        #    ┌───┴────┐   ┌─┴─┐
        #   12       19   3   4
        #  ┌─┴─┐   ┌──┘
        # 11  14  16

        input = [13, 15, 10, 12, 19, 3, 4, 11, 14, 16]
        expected_min_values = [3, 11, 3, 11, 16, 3, 4, 11, 14, 16]
        m = self.__class__.matcher

        computed_min_values = []
        for i in range(10):
            min_value = 100
            min_index = -1
            (min_value, min_index) = m.subtree_min_index(input, i, min_value,
                min_index)
            computed_min_values.append(min_value)

        self.assertListEqual(expected_min_values, computed_min_values)

        #              10
        #        ┌──────┴───┐
        #       12         11
        #    ┌───┴────┐   ┌─┴─┐
        #   15       16  13  14
        #  ┌─┴─┐   ┌──┘
        # 18  17  19
        input = [10, 12, 11, 15, 16, 13, 14, 18, 17, 16]
        expected_min_values = input

        computed_min_values = []
        for i in range(10):
            min_value = 100
            min_index = -1
            (min_value, min_index) = m.subtree_min_index(input, i, min_value,
                min_index)
            computed_min_values.append(min_value)

        self.assertListEqual(expected_min_values, computed_min_values)


    def test_smallest_instantly_up(self):
        """Tests Smallest-Instantly-Up heapify variant."""

        #             (13)                      3                       3
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       15         10          (15)        10           11        (10)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   12       19  (3)  4     12       19  13   4     12       19  13  (4)
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  11  16             (11) 11  16              15  11  16
        #
        #               3                       3                       3
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       11          4           11          4           11          4
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (12)      19  13   4     11      (19) 13   4     11       16  13   4
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 15 (11) 16              15  12 (16)             15  12  19

        input = [13, 15, 10, 12, 19, 3, 4, 11, 11, 16]
        expected_swaps = [(0, 5), (1, 7), (2, 6), (3, 8), (4, 9)]

        m = self.__class__.matcher
        main_loop = m.loop_variants[4][2]  # Top-down / level order
        heapify = m.smallest_instantly_up

        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        self.assertListEqual(expected_swaps, actual_swaps)

    def test_build_min_heap_dr_level(self):
        """Tests level-by-level delayed recursion."""

        # heap                              index
        #                15                 0
        #        ┌────────┴──────┐
        #       14              13          1-2
        #    ┌───┴───┐       ┌───┴───┐
        #  (12)    (11)    (10)     (9)     3-6
        #  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐
        #  8  (7)  6  (5)  4  (3)  2  (1)   7-14
        #
        #  swaps: (6,14) (5,12) (4,10), (3,8)
        #
        #                15                 0
        #        ┌────────┴──────┐
        #      (14)            (13)         1-2
        #    ┌───┴───┐       ┌───┴───┐
        #    7      (5)      3      (1)     3-6
        #  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐
        #  8  12  (6) 11   4  10  (2)  9    7-14
        #
        #  swaps: (2,6) (6,14)R (1,4) (4,9)R   (R is recursive swap)
        #
        #               (15)                0
        #        ┌────────┴──────┐
        #        5              (1)         1-2
        #    ┌───┴───┐       ┌───┴───┐
        #    7       6       3      (2)     3-6
        #  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐
        #  8  12  14  11   4  10  13  (9)   7-14
        #
        #  swaps: (0,2) (2,6)R (6,15)R


        input = [i for i in range(15, 0, -1)]
        expected_swaps = [
            (6, 14, False), (5, 12, False), (4, 10, False), (3, 8, False),
            (2,  6, False), (1,  4, False), (6, 13, True),  (4, 9, True),
            (0,  2, False), (2,  6, True),  (6, 14, True)
            ]
        m = self.__class__.matcher
        actual_swaps = m.build_min_heap_dr_level(input, True)
        self.assertListEqual(actual_swaps, expected_swaps)

    def test_build_min_heap_dr_end(self):
        """Tests level-by-level delayed recursion."""

        # heap                              index
        #                15                 0
        #        ┌────────┴──────┐
        #       14              13          1-2
        #    ┌───┴───┐       ┌───┴───┐
        #  (12)    (11)    (10)     (9)     3-6
        #  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐
        #  8  (7)  6  (5)  4  (3)  2  (1)   7-14
        #
        #  swaps: (6,14) (5,12) (4,10), (3,8)
        #
        #                15                 0
        #        ┌────────┴──────┐
        #      (14)            (13)         1-2
        #    ┌───┴───┐       ┌───┴───┐
        #    7      (5)      3      (1)     3-6
        #  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐
        #  8  12  (6) 11   4  10  (2)  9    7-14
        #
        #  swaps: (2,6) (6,14)R (1,4) (4,9)R   (R is recursive swap)
        #
        #               (15)                0
        #        ┌────────┴──────┐
        #        5              (1)         1-2
        #    ┌───┴───┐       ┌───┴───┐
        #    7       6       3      (2)     3-6
        #  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐
        #  8  12  14  11   4  10  13  (9)   7-14
        #
        #  swaps: (0,2) (2,6)R (6,15)R


        input = [i for i in range(15, 0, -1)]
        expected_swaps = [
            (6, 14, False), (5, 12, False), (4, 10, False), (3, 8, False),
            (2,  6, False), (1,  4, False),
            (0,  2, False),
            (6, 13, True),  (4, 9, True), (2,  6, True),  (6, 14, True)
            ]
        m = self.__class__.matcher
        actual_swaps = m.build_min_heap_dr_end(input, True)
        self.assertListEqual(actual_swaps, expected_swaps)

    def test_state_similarity_dr_level(self):
        """State similarity of delayed recursion when recursive swaps are
        after each level in the heap."""
        m = self.__class__.matcher
        heap_size = 15
        input = [i for i in range(heap_size, 0, -1)]
        # Example output from BuildHeapMatcher.build_min_heap_dr_level()
        C_swaps = [
            (6, 14, False), (5, 12, False), (4, 10, False), (3, 8, False),
            (2,  6, False), (1,  4, False), (6, 13, True),  (4, 9, True),
            (0,  2, False), (2,  6, True),  (6, 14, True)
            ]

        self.assertEqual(m.state_similarity_dr(input, C_swaps, C_swaps,
            heap_size),
            len(C_swaps))


        # Altered order of recursive swaps after level 1
        S_swaps = C_swaps[0:6] + [C_swaps[7], C_swaps[6]] + C_swaps[8:]
        self.assertEqual(m.state_similarity_dr(input, C_swaps, S_swaps,
            heap_size), len(C_swaps))

        # Altered order of recursive swaps after level 0
        S_swaps = C_swaps[0:9] + [C_swaps[10], C_swaps[9]]
        self.assertEqual(m.state_similarity_dr(input, C_swaps, S_swaps,
            heap_size), len(C_swaps))

        # Altered order of recursive swaps after levels 1 and 0
        S_swaps = C_swaps[0:6] + [C_swaps[7], C_swaps[6], C_swaps[8],
            C_swaps[10], C_swaps[9]]
        self.assertEqual(m.state_similarity_dr(input, C_swaps, S_swaps,
            heap_size), len(C_swaps))

        # One nonrecursive swap missing
        S_swaps = C_swaps[0:6] + [C_swaps[7], C_swaps[6],
            C_swaps[10], C_swaps[9]]
        self.assertEqual(m.state_similarity_dr(input, C_swaps, S_swaps,
            heap_size), len(S_swaps))

        # One recursive swap missing
        S_swaps = C_swaps[0:6] + [C_swaps[7], C_swaps[8],
            C_swaps[10], C_swaps[9]]
        self.assertEqual(m.state_similarity_dr(input, C_swaps, S_swaps,
            heap_size), len(S_swaps))

    def test_state_similarity_dr_end(self):
        """State similarity of delayed recursion when all recursive swaps are
        in the end of the sequence."""
        m = self.__class__.matcher
        heap_size = 15
        input = [i for i in range(heap_size, 0, -1)]
        # Example output from BuildHeapMatcher.build_min_heap_dr_end()
        C_swaps = [
            (6, 14, False), (5, 12, False), (4, 10, False), (3, 8, False),
            (2,  6, False), (1,  4, False), (0,  2, False),
            (6, 13, True),  (4, 9, True), (2,  6, True),  (6, 14, True)
            ]

        self.assertEqual(m.state_similarity_dr(input, C_swaps, C_swaps,
            heap_size),
            len(C_swaps))

        # test with some permutations (not all 4! = 24 of them)
        permutations = [(0, 1, 2, 3), (0, 1, 3, 2), (0, 2, 1, 3), (0, 2, 3, 1),
                        (0, 3, 1, 2), (0, 3, 2, 1),
                        (1, 0, 2, 3), (2, 0, 3, 1)]
        for p in permutations:
            S_swaps = C_swaps[0:7]
            for i in p:
                S_swaps.append(C_swaps[7 + i])
            self.assertEqual(m.state_similarity_dr(input, C_swaps, S_swaps,
                heap_size), len(C_swaps))

        # One nonrecursive swap missing
        S_swaps = C_swaps[0:3] + C_swaps[4:]
        self.assertEqual(m.state_similarity_dr(input, C_swaps, S_swaps,
            heap_size),
            10)

        # One recursive swap missing
        S_swaps = C_swaps[0:8] + C_swaps[9:]
        self.assertEqual(m.state_similarity_dr(input, C_swaps, S_swaps,
            heap_size),
            10)

    def test_single_skips(self):
        """Single-skips variants generation test."""
        m = self.__class__.matcher
        heap_size = 10
        input = [i for i in range(heap_size, 0, -1)]
        sequences = m.single_skips(input)

        # All swaps of the correct variant (R = recursive):
        #   1     2     3     4     5      6     7      8
        # (4,9) (3,8) (2,6) (1,4) (4,9)R (0,1) (1,3)R (3,7)R

        expected_sequences = [
            # swap 1 omitted
            # 0   1  2  3  4  5  6  7  8  9   index
            [(10, 9, 8, 7, 6, 5, 4, 3, 2, 1), # (3,8)
             (10, 9, 8, 2, 6, 5, 4, 3, 7, 1), # (2,6)
             (10, 9, 4, 2, 6, 5, 8, 3, 7, 1), # (1,4)
             (10, 6, 4, 2, 9, 5, 8, 3, 7, 1), # (4,9)
             (10, 6, 4, 2, 1, 5, 8, 3, 7, 9), # (0,1)
             ( 6, 10,4, 2, 1, 5, 8, 3, 7, 9), # (1,3)
             ( 6, 2, 4,10, 1, 5, 8, 3, 7, 9), # (3,7)
             ( 6, 2, 4, 3, 1, 5, 8,10, 7, 9)
            ],
            # swap 2 omitted
            # 0   1  2  3  4  5  6  7  8  9   index
            [(10, 9, 8, 7, 6, 5, 4, 3, 2, 1), # (4,9)
             (10, 9, 8, 7, 1, 5, 4, 3, 2, 6), # (2,6)
             (10, 9, 4, 7, 1, 5, 8, 3, 2, 6), # (1,4)
             (10, 1, 4, 7, 9, 5, 8, 3, 2, 6), # (4,9)
             (10, 1, 4, 7, 6, 5, 8, 3, 2, 9), # (0,1)
             ( 1,10, 4, 7, 6, 5, 8, 3, 2, 9), # (1,3)
             ( 1, 7, 4,10, 6, 5, 8, 3, 2, 9), # (3,7)
             ( 1, 7, 4, 3, 6, 5, 8,10, 2, 9)
            ],
            # swap 3 omitted
            # 0   1  2  3  4  5  6  7  8  9   index
            [(10, 9, 8, 7, 6, 5, 4, 3, 2, 1), # (4,9)
             (10, 9, 8, 7, 1, 5, 4, 3, 2, 6), # (3,8)
             (10, 9, 8, 2, 1, 5, 4, 3, 7, 6), # (1,4)
             (10, 1, 8, 2, 9, 5, 4, 3, 7, 6), # (4,9)
             (10, 1, 8, 2, 6, 5, 4, 3, 7, 9), # (0,1)
             ( 1,10, 8, 2, 6, 5, 4, 3, 7, 9), # (1,3)
             ( 1, 2, 8,10, 6, 5, 4, 3, 7, 9), # (3,7)
             ( 1, 2, 8, 3, 6, 5, 4,10, 7, 9)
            ],
            # swap 4 (and thus 5) omitted
            # 0   1  2  3  4  5  6  7  8  9   index
            [(10, 9, 8, 7, 6, 5, 4, 3, 2, 1), # (4,9)
             (10, 9, 8, 7, 1, 5, 4, 3, 2, 6), # (3,8)
             (10, 9, 8, 2, 1, 5, 4, 3, 7, 6), # (2,6)
             (10, 9, 4, 2, 1, 5, 8, 3, 7, 6), # (0,1)
             (9, 10, 4, 2, 1, 5, 8, 3, 7, 6), # (1,3)
             (9,  2, 4,10, 1, 5, 8, 3, 7, 6), # (3,7)
             (9,  2, 4, 3, 1, 5, 8,10, 7, 6)
            ],
            # swap 5 omitted
            # 0   1  2  3  4  5  6  7  8  9   index
            [(10, 9, 8, 7, 6, 5, 4, 3, 2, 1), # (4,9)
             (10, 9, 8, 7, 1, 5, 4, 3, 2, 6), # (3,8)
             (10, 9, 8, 2, 1, 5, 4, 3, 7, 6), # (2,6)
             (10, 9, 4, 2, 1, 5, 8, 3, 7, 6), # (1,4)
             (10, 1, 4, 2, 9, 5, 8, 3, 7, 6), # (0,1)
             ( 1,10, 4, 2, 9, 5, 8, 3, 7, 6), # (1,3)
             ( 1, 2, 4,10, 9, 5, 8, 3, 7, 6), # (3,7)
             ( 1, 2, 4, 3, 9, 5, 8,10, 7, 6)
            ],
            # swap 6 (and thus 7 and 8) omitted
            # 0   1  2  3  4  5  6  7  8  9   index
            [(10, 9, 8, 7, 6, 5, 4, 3, 2, 1), # (4,9)
             (10, 9, 8, 7, 1, 5, 4, 3, 2, 6), # (3,8)
             (10, 9, 8, 2, 1, 5, 4, 3, 7, 6), # (2,6)
             (10, 9, 4, 2, 1, 5, 8, 3, 7, 6), # (1,4)
             (10, 1, 4, 2, 9, 5, 8, 3, 7, 6), # (4,9)
             (10, 1, 4, 2, 6, 5, 8, 3, 7, 9)
            ],
            # swap 7 (and thus 8) omitted
            # 0   1  2  3  4  5  6  7  8  9   index
            [(10, 9, 8, 7, 6, 5, 4, 3, 2, 1), # (4,9)
             (10, 9, 8, 7, 1, 5, 4, 3, 2, 6), # (3,8)
             (10, 9, 8, 2, 1, 5, 4, 3, 7, 6), # (2,6)
             (10, 9, 4, 2, 1, 5, 8, 3, 7, 6), # (1,4)
             (10, 1, 4, 2, 9, 5, 8, 3, 7, 6), # (4,9)
             (10, 1, 4, 2, 6, 5, 8, 3, 7, 9), # (0,1)
             ( 1,10, 4, 2, 6, 5, 8, 3, 7, 9)
            ],
            # swap 8 omitted
            # 0   1  2  3  4  5  6  7  8  9   index
            [(10, 9, 8, 7, 6, 5, 4, 3, 2, 1), # (4,9)
             (10, 9, 8, 7, 1, 5, 4, 3, 2, 6), # (3,8)
             (10, 9, 8, 2, 1, 5, 4, 3, 7, 6), # (2,6)
             (10, 9, 4, 2, 1, 5, 8, 3, 7, 6), # (1,4)
             (10, 1, 4, 2, 9, 5, 8, 3, 7, 6), # (4,9)
             (10, 1, 4, 2, 6, 5, 8, 3, 7, 9), # (0,1)
             ( 1,10, 4, 2, 6, 5, 8, 3, 7, 9), # (1,3)
             ( 1, 2, 4,10, 6, 5, 8, 3, 7, 9)
            ]
         ]
        self.assertListEqual(sequences[0], expected_sequences[0])
        self.assertListEqual(sequences[1], expected_sequences[1])
        self.assertListEqual(sequences[2], expected_sequences[2])
        self.assertListEqual(sequences[3], expected_sequences[3])
        self.assertListEqual(sequences[4], expected_sequences[4])
        self.assertListEqual(sequences[5], expected_sequences[5])
        self.assertListEqual(sequences[6], expected_sequences[6])
        self.assertListEqual(sequences[7], expected_sequences[7])

    def test_end_state_is_minimum_heap(self):
        f = self.__class__.matcher.min_heap_property
        self.assertTrue(f([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 0))
        self.assertTrue(f([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 0))
        self.assertFalse(f([9, 8, 7, 6, 5, 4, 3, 2, 1, 0], 0))

        # A                        B                      C
        #              14                      14                     10
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       10         11           10         11           14         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15       17  12  13     15       16  12  13     15       16  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18  16              19  18  17              19  18  17

        A = [14, 10, 11, 15, 17, 12, 13, 19, 18, 16]
        self.assertFalse(f(A, 0))
        self.assertFalse(f(A, 1))
        self.assertTrue(f(A, 2))
        self.assertTrue(f(A, 3))
        self.assertFalse(f(A, 4))
        self.assertTrue(f(A, 5))
        self.assertTrue(f(A, 6))
        self.assertTrue(f(A, 7))
        self.assertTrue(f(A, 8))
        self.assertTrue(f(A, 9))

        B = [14, 10, 11, 15, 16, 12, 13, 19, 18, 17]
        C = [10, 14, 11, 15, 16, 12, 13, 19, 18, 17]

        self.assertFalse(f(B, 0))
        self.assertTrue(f(C, 0))

    def test_correct_with_extra_steps(self):
        f = self.__class__.matcher.correct_with_extra_steps

        self.assertFalse(f("ABCD", "ABCD"))
        self.assertFalse(f("ABCD", "ABCDE"))

        self.assertTrue(f("ABCDE", "ABCD"))
        self.assertFalse(f("ABDE", "ABCD"))

    def test_swaps_resemble_build_heap(self):
        f = self.__class__.matcher.swaps_resemble_build_heap

        #               0
        #        ┌──────┴───┐
        #        1          2
        #    ┌───┴────┐   ┌─┴─┐
        #    3        4   5   6
        #  ┌─┴─┐   ┌──┘
        #  7   8   9
        heap_size = 10
        self.assertTrue(f([(4,9), (3,8), (2, 5), (1, 4), (4, 9),
                          (0, 1), (1, 4), (4, 9)], heap_size))

        # Main loop condition breaks, illegal
        self.assertFalse(f([(3,8), (4,9), (2, 5), (1, 4), (4, 9),
                  (0, 1), (1, 4), (4, 9)], heap_size))

        # First wwap (4,9) removed, legal
        self.assertTrue(f([(3,8), (2, 5), (1, 4), (4, 9),
                          (0, 1), (1, 4), (4, 9)], heap_size))

        # Child-child swap, illegal
        self.assertFalse(f([(7,8), (2, 5), (1, 4), (4, 9),
                          (0, 1), (1, 4), (4, 9)], heap_size))

        # Different level, illegal
        self.assertFalse(f([(1,8), (2, 5), (1, 4), (4, 9),
                          (0, 1), (1, 4), (4, 9)], heap_size))

        # Different branch, illegal
        self.assertFalse(f([(5,8), (2, 5), (1, 4), (4, 9),
                          (0, 1), (1, 4), (4, 9)], heap_size))

        #              14                      14                      14
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       17         13           17         13           17        (13)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   10      (16) 12  11    (10)      10  12  11      9       10  12 (11)
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19   9 (10)             19  (9) 16              19  10  16
        #
        #              14                      14                     (10)
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      (17)        11            9         11           (9)        11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   (9)      10  12  13    (17)      10  12  13     10       10  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  10  16              19 (10) 16              19  17  16
        #
        #               9
        #        ┌──────┴───┐
        #       10         11
        #    ┌───┴────┐   ┌─┴─┐
        #   10       10  12  13
        #  ┌─┴─┐   ┌──┘
        # 19  10  16

        # Image sequence above
        self.assertTrue(f([(4,9), (3,8), (2,6), (1,3), (3,8), (0,1)],
            heap_size))

        # This is also legal
        #              14                      14                      14
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       11         13           11         13           11        (13)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   12      (16) 12  11    (12)      10  12  11      9       10  12 (11)
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        #  9  10 (10)             (9) 10  16              12  10  16
        #
        #              14                      14                     (14)
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      (11)        11            9         11           (9)        11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   (9)      10  12  13    (11)      10  12  13     10       10  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 12  10  16              12 (10) 16              19  11  16
        #
        #               9                       9
        #        ┌──────┴───┐            ┌──────┴───┐
        #      (14)        11           10         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (10)      10  12  13     14       10  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  11  16              19  11  16

        self.assertTrue(f([(4,9), (3,7), (2,6), (1,3), (3,8), (0,1), (1,3)],
            heap_size))

    def test_swaps_are_legal(self):
        f = self.__class__.matcher.swaps_are_legal
        g = self.__class__.matcher.swaps_are_legal_by_index

        # This is again a correct Build-min-heap sequence, but its swaps are
        # reused here for test data.
        #
        #              14                      14                      14
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       11         13           11         13           11        (13)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   12      (16) 12  11    (12)      10  12  11      9       10  12 (11)
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        #  9  10 (10)             (9) 10  16              12  10  16
        #
        #              14                      14                     (14)
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #      (11)        11            9         11           (9)        11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   (9)      10  12  13    (11)      10  12  13     10       10  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 12  10  16              12 (10) 16              19  11  16
        #
        #               9                       9
        #        ┌──────┴───┐            ┌──────┴───┐
        #      (14)        11           10         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (10)      10  12  13     14       10  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  11  16              19  11  16
        input = [14, 11, 13, 12, 16, 12, 11, 9, 10, 10]
        swaps = [(4,9), (3,7), (2,6), (1,3), (3,8), (0,1), (1,3)]
        states = self.states_from_swaps(input, swaps)
        self.assertTrue(f(states, swaps, len(input)))
        self.assertTrue(g(swaps, len(input)))

        # Illegal swap: children of the same parent
        swaps = [(7,8)]
        states = self.states_from_swaps(input, swaps)
        self.assertFalse(f(states, swaps, len(input)))
        self.assertFalse(g(swaps, len(input)))

        # Illegal swap: same level, different parent
        swaps = [(7,9)]
        states = self.states_from_swaps(input, swaps)
        self.assertFalse(f(states, swaps, len(input)))
        self.assertFalse(g(swaps, len(input)))

        # Illegal swap: different levels
        swaps = [(1,9)]
        states = self.states_from_swaps(input, swaps)
        self.assertFalse(f(states, swaps, len(input)))
        self.assertFalse(g(swaps, len(input)))

        # Illegal swap: different branches
        swaps = [(1,5)]
        states = self.states_from_swaps(input, swaps)
        self.assertFalse(f(states, swaps, len(input)))
        self.assertFalse(g(swaps, len(input)))

        # Swap larger child: Second swap (3,8) instead of (3,7)
        # (Parent 12, children 9 and 10, swap 12 and 10.)
        swaps = [(4,9), (3,8), (2,6), (1,3), (3,8), (0,1), (1,3)]
        states = self.states_from_swaps(input, swaps)
        self.assertFalse(f(states, swaps, len(input)))
        self.assertTrue(g(swaps, len(input)))

        # Wrong-duplicate
        # (Parent 14, children 11 and 11, choose right child)
        swaps = [(4,9), (3,7), (2,6), (0,2), (3,8), (0,1), (1,3)]
        states = self.states_from_swaps(input, swaps)
        self.assertFalse(f(states, swaps, len(input)))
        self.assertTrue(g(swaps, len(input)))

        # Correct duplicate
        # (Parent 14, children 11 and 11, choose left child)
        swaps = [(4,9), (3,7), (2,6), (0,1), (3,8), (0,1), (1,3)]
        states = self.states_from_swaps(input, swaps)
        self.assertFalse(f(states, swaps, len(input)))
        self.assertTrue(g(swaps, len(input)))

        # No need to swap
        # (Parent 9, children 11 and 10, choose the left child
        input = [9, 11, 10]
        swaps = [(0, 1)]
        states = self.states_from_swaps(input, swaps)
        self.assertFalse(f(states, swaps, len(input)))
        self.assertTrue(g(swaps, len(input)))

        # No need to swap
        # (Parent 9, children 11 and 10, choose the right child
        input = [9, 11, 10]
        swaps = [(0, 2)]
        states = self.states_from_swaps(input, swaps)
        self.assertFalse(f(states, swaps, len(input)))
        self.assertTrue(g(swaps, len(input)))




class TestDTW(unittest.TestCase):

    def print_array(self, A, w, h):
        s = ""
        for i in range(h):
            for j in range(w):
                s += "{:2.0f} ".format(A[i * w + j])
            s += "\n"
        print(s)

    def d(self, x, y):
        return abs(x - y)

    def test_zero(self):
        """If one of sequences has zero length, dtw is zero."""
        X = []
        Y = [1, 2]
        self.assertEqual(dtw(X, Y, self.d), 0)
        self.assertEqual(dtw(Y, X, self.d), 0)

    def test_identity(self):
        """dtw(x,x) == 0"""
        X = [1, 3, 2, 4]
        self.assertEqual(dtw(X, X, self.d), 0)

    def test_symmetricity(self):
        X = [1, 3, 2, 4]
        Y = [1, 5, 3, 8]
        d1 = dtw(X, Y, self.d)
        d2 = dtw(Y, X, self.d)
        self.assertTrue(d1 > 0)
        self.assertTrue(d2 > 0)
        self.assertEqual(d1, d2)

    def test_array(self):
        """Pen and paper worked example"""

        X = [0, 4, 3, 1, 4, 3, 2, 0]
        Y = [0, 4, 2, 0, 4, 2, 0, 4, 2]

        expected_g = [ 0,  4,  7,  8, 12, 15, 17, 17,
                       4,  0,  1,  4,  4,  5,  7, 11,
                       6,  2,  2,  3,  5,  6,  5,  7,
                       6,  6,  5,  4,  8,  9,  7,  5,
                      10,  6,  6,  7,  4,  5,  7,  9,
                      12,  8,  7,  8,  6,  6,  5,  7,
                      12, 12, 10,  9, 10,  9,  7,  5,
                      16, 12, 11, 12,  9, 10,  9,  9,
                      18, 14, 12, 13, 11, 11,  9, 11]

        g = dtw(X, Y, self.d, return_array = True)
        #self.print_array(g, len(X), len(Y))

        self.assertEqual(len(g), len(expected_g),
            "Size of dynamic programming array differs from expected.")

        msg = "Dynamic programming array at index {} differs from expected."
        for i in range(len(expected_g)):

            self.assertAlmostEqual(g[i], expected_g[i],
                msg = (msg.format(i)))


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()
