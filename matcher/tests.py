'''
Created on 4 Dec 2019

@author: atilante
'''
import copy
import unittest
from buildheap import BuildHeapMatcher
from dtw import dtw

class TestBuildHeapMatcher(unittest.TestCase):

    @classmethod
    def setUpClass(cls):        
        cls.matcher = BuildHeapMatcher()
    
    def states_from_swaps(self, input, swaps):
        """Helper method which creates a sequence of states from input and
        swaps.
        
        Parameters:
        input (list of integers): a heap array
        swaps (list of tuples): each tuple is (x, y, ...), where x and y are
                                the indices of the swap, and the rest is
                                optional (such as with testing the Delayed
                                recursion algorithm variants)
        
        Returns:
        list of tuples: each tuple is a state of the heap array. There are
        len(swaps) + 1 states, and the first one is the input."""
        
        states = [tuple(input)]
        A = copy.copy(input)
        for s in swaps:
            A[s[0]], A[s[1]] = A[s[1]], A[s[0]]
            states.append(tuple(A))
        return states
    
    def swap_indices(self, S, i, j):
        S[i], S[j] = S[j], S[i]
    
    def test_states_and_swaps(self):
        """Self-test: states_from_swaps() helper method"""
        input = [14, 17, 13, 15, 16, 12, 11, 19, 18, 10]
        swaps = [(4, 9), (2, 6), (1, 4), (4, 9), (0, 1)]
        expected_states = [
            # 0   1   2   3   4   5   6   7   8   9
            (14, 17, 13, 15, 16, 12, 11, 19, 18, 10),
            (14, 17, 13, 15, 10, 12, 11, 19, 18, 16),
            (14, 17, 11, 15, 10, 12, 13, 19, 18, 16),
            (14, 10, 11, 15, 17, 12, 13, 19, 18, 16),
            (14, 10, 11, 15, 16, 12, 13, 19, 18, 17),
            (10, 14, 11, 15, 16, 12, 13, 19, 18, 17)
            ]
        states = self.states_from_swaps(input, swaps)
        self.assertListEqual(states, expected_states)
    
    
    def test_parse_recording(self):
        """Tests a Build-heap recording parsed from JSON generated by the
        JSAV exercise."""
        
        recording = []        
        input = [14, 17, 13, 15, 16, 12, 11, 19, 18, 10]
        A = copy.copy(input)
        swaps = [(4, 9), (2, 6), (1, 4), (4, 9), (0, 1)]
        states = []
        
        recording.append({
            'ind': [{'v': x} for x in A],
            'style': 'height: 60px; width: 301px;',
            'classes': ['jsavcenter'] })
        states.append(tuple(A))
        
        for s in swaps:
            A[s[0]], A[s[1]] = A[s[1]], A[s[0]]
            recording.append({
              'ind': [{'v': x} for x in A],
              'style': 'height: 60px; width: 301px;',
              'classes': ['jsavcenter'] })
            states.append(tuple(A))
            
        m = self.__class__.matcher
        
        (result_input,
        result_states,
        result_swaps) = m.parse_recording(recording)
        
        self.assertListEqual(input, result_input)
        self.assertListEqual(states, result_states)
        self.assertListEqual(swaps, result_swaps)
        
    def test_state_similarity(self):
        """Tests state_similarity()"""
        
        sim = self.__class__.matcher.state_similarity
        
        # candidate sequence
        candidate = [(1, 2, 3), (3, 1, 2), (2, 1, 3)]
        
        # Empty candidate or student's sequence should result in 0
        self.assertEqual(sim(candidate, []), 0)
        self.assertEqual(sim([], candidate), 0)
        
        # Identical sequences should result in length of the sequence
        self.assertEqual(sim(candidate, candidate), len(candidate))
        
        # If only the first state is the same, the result should be 1
        student = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
        self.assertEqual(sim(candidate, student), 1)
        
        # Two matching states from the beginning
        student = [candidate[0], candidate[1], (2, 2, 2)]
        self.assertEqual(sim(candidate, student), 2)
        
        # Two matching, one mismatch, one match
        student.append(candidate[2])
        self.assertEqual(sim(candidate, student), 3)
        
        # One duplicate state in student's sequence should be counted only once
        # (Also: maximum return value is the length of the shorter sequence)
        student = [candidate[0], candidate[1], candidate[2], candidate[2]]
        self.assertEqual(sim(candidate, student), 3)
        
        # One missing state in student's sequence
        # (Also: maximum return value is the length of the shorter sequence)
        student = [candidate[0], candidate[1]]
        self.assertEqual(sim(candidate, student), 2)
        
        # Wrong order of states causes mismatch
        student = [candidate[0], candidate[2], candidate[1]]
        self.assertEqual(sim(candidate, student), 2)

    def test_lcs(self):
        
        lcs = self.__class__.matcher.lcs
        
        sim, matches = lcs("ABCBDAB", "BDCABA")
        
        # 0 1 2 3 4 5 6 7
        # A B C B D A B
        #  /  |  \  |
        # B D C A B A
        
        self.assertEqual(sim, 4)
        self.assertListEqual(matches, [(1,0), (2,2), (3,4), (5,5)])

    def test_lcs_similarity(self):
        
        lcs = self.__class__.matcher.lcs_similarity
        
        # Example from:
        # Cormen, Leiserson, Rivest, Stein: Introduction to Algorithms (3rd ed.).
        # MIT Press 2009. ISBN 9780262270830. Page 395.
        self.assertEqual(lcs("ABCBDAB", "BDCABA"), 4)
        
        # The same example with tuples
        self.assertEqual(lcs(
            [(0, 1), (2, 3), (4, 5), (2, 3), (6, 7), (0, 1), (2, 3)],
            [(2, 3), (6, 7), (4, 5), (0, 1), (2, 3), (0, 1)]), 4)
        
        # Zero cases
        self.assertEqual(lcs([], []), 0)
        self.assertEqual(lcs([(1, 0)], []), 0)
        self.assertEqual(lcs([], [(0, 1)]), 0)
        
        # One missing element
        self.assertEqual(lcs([(4, 9), (2, 6), (1, 4), (4, 9), (0, 1)],
                             [(4, 9), (2, 6), (1, 4), (0, 1)]), 4)
        
        # One differing element at equal index
        self.assertEqual(lcs([(4, 9), (2, 6), (1, 4), (4, 9), (0, 1)],
                             [(4, 9), (2, 6), (1, 4), (4, 8), (0, 1)]), 4)
        
        # One differing element at different index
        self.assertEqual(lcs([(4, 9), (2, 6), (1, 4), (4, 9), (0, 1)],
                             [(4, 9), (2, 6), (4, 8), (1, 4), (0, 1)]), 4)
        
        # All elements same but one in different position
        self.assertEqual(lcs([(4, 9), (2, 6), (1, 4), (4, 9), (0, 1)],
                             [(4, 9), (2, 6), (4, 9), (1, 4), (0, 1)]), 4)        


    def test_Correct_Correct(self):
        """Correct loop, correct heapify"""
    
        #              14                      14                      14     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       17         13           17        (13)          (17)       11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 12  11     15       10  12 (11)    15      (10) 12  13      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (10)             19  18  16              19  18  16
        #
        #              14                     (14)                    10     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #      10          11          (10)        11           14         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (17) 12  13     15       16  12  13     15       16  12  13      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (16)             19  18  17              19  18  17
        #

        input = [14, 17, 13, 15, 16, 12, 11, 19, 18, 10]
        swaps = [(4, 9), (2, 6), (1, 4), (4, 9), (0, 1)] # heap array indices
        
        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        heapify = m.min_heapify        # Correct
        
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        
        self.assertListEqual(swaps, actual_swaps)
        

    def test_Correct_Delayed_recursion(self):
        """Correct loop, heapify with delayed recursion """
        
        # Correct variant: there is one recursive swap, the fourth swap (4,9).
        #
        #              14                      14                      14     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       17         13           17        (13)          (17)       11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 12  11     15       10  12 (11)    15      (10) 12  13      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (10)             19  18  16              19  18  16
        #
        #              14                     (14)                    10     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #      10          11          (10)        11           14         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (17) 12  13     15       16  12  13     15       16  12  13      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (16)             19  18  17              19  18  17
        #
        # Delayed recursion: fourth swap (4,9) is the fifth swap.
        # Invalid variants: fourth swap (4,9) is the second or third swap.
        
        input = [14, 17, 13, 15, 16, 12, 11, 19, 18, 10]
        
        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        
        A = list(input)
        states = []
        swaps = []
        for i in main_loop:
            m.delayed_recursion(A, i, states, swaps)
        
        
        swaps_expected = [(4, 9, False), (2, 6, False), (1, 4, False),
            (4, 9, True), (0, 1, False)]
        self.assertListEqual(swaps, swaps_expected)
        

        
    def test_Correct_Delayed_recursion_similarity(self):
        # The same input as in test_Correct_Delayed_recursion()        
        
        # Correct variant: there is one recursive swap, the fourth swap (4,9).
        #
        #              14                      14                      14     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       17         13           17        (13)          (17)       11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 12  11     15       10  12 (11)    15      (10) 12  13      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (10)             19  18  16              19  18  16
        #
        #              14                     (14)                    10     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #      10          11          (10)        11           14         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (17) 12  13     15       16  12  13     15       16  12  13      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (16)             19  18  17              19  18  17
        
        input = [14, 17, 13, 15, 16, 12, 11, 19, 18, 10]      

        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        
        # C_swaps are the "candidate swaps"; it imitates a swap sequence with
        # recursion information as BuildHeapMatcher.delayed_recursion() would
        # have produced it.
        C_swaps  = [(4, 9, False), (2, 6, False), (1, 4, False),
            (4, 9, True), (0, 1, False)]        
            
        #
        # The following tests are similar to test_state_similarity().
        #
        S_swaps = [s[0:2] for s in C_swaps]
        
        # Identical sequences should result in 0, because order is the same and
        # thus this is not delayed recursion.
        self.assertEqual(m.lcs_similarity_delayed_recursion(
            C_swaps, S_swaps), 0)
         
        # Empty candidate or student's sequence should result in 0
        self.assertEqual(m.lcs_similarity_delayed_recursion(
            C_swaps, []), 0)
        self.assertEqual(m.lcs_similarity_delayed_recursion(
            [], S_swaps), 0)
               
  
        # TODO: actual delayed recursion example, maximum number of recursive
        # swaps with heap size of 10.
         
        #              19                      19                      19     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       18         17           18         17           18        (17)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   16      (15) 14  13    (16)      10  14  13     11       10  14 (13)     
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 12  11 (10)             12 (11) 15              12  16  15
        #
        #              19                      19                     (19)    
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #      (18)        13           10         13          (10)        13 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   11      (10) 14  17     11      (18) 14  17     11       15  14  17     
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 12  16  15              12  16 (15)             12  16  18        
        #
        #              10                      10                      10     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #      (19)        13           11         13           11         13 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (11)      15  14  17    (19)      15  14  17     12       15  14  17     
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 12  16  18             (12) 16  18              19  16  18        
 
        input = [i for i in range(19, 9, -1)]
        C_swaps  = [(4, 9, False), (3, 8, False), (2, 6, False), # 0-2
                      (1, 4, False), (4, 9, True), (0, 1, False),  # 3-5
                      (1, 3, True), (3, 7, True)]                  # 6,7
        
        S_swaps = [s[0:2] for s in C_swaps]   

        # Legal delayed recursion swaps                 
        swaps_delayed = [
            # correct order:[(4, 9), (0, 1), (1, 3), (3, 7)]
            S_swaps[0:4] + [(4, 9), (0, 1), (3, 7), (1, 3)],
            S_swaps[0:4] + [(0, 1), (4, 9), (1, 3), (3, 7)],
            S_swaps[0:4] + [(0, 1), (4, 9), (3, 7), (1, 3)],
            S_swaps[0:4] + [(0, 1), (1, 3), (4, 9), (3, 7)],
            S_swaps[0:4] + [(0, 1), (3, 7), (4, 9), (1, 3)],
            S_swaps[0:4] + [(0, 1), (1, 3), (3, 7), (4, 9)],
            S_swaps[0:4] + [(0, 1), (3, 7), (1, 3), (4, 9)]]
        
        similarities = []
        for s in swaps_delayed:
            similarities.append(m.lcs_similarity_delayed_recursion(C_swaps, s))            
        self.assertEqual(similarities, [8] * len(swaps_delayed))
            
        # Illegal swaps: a recursive swap appears earlier than it should.
        # These will not be counted as recursive swaps.
        swaps_illegal = [
            # Recursive swap (4,9) at indices 1..3            
            [(4, 9), (4, 9), (3, 8), (2, 6), (1, 4), (0, 1), (1, 3), (3, 7)],
            [(4, 9), (3, 8), (4, 9), (2, 6), (1, 4), (0, 1), (1, 3), (3, 7)],
            [(4, 9), (3, 8), (2, 6), (4, 9), (1, 4), (0, 1), (1, 3), (3, 7)],
            
            # Recursive swap (1,3) at indices 0..5
            [(1, 3), (4, 9), (3, 8), (2, 6), (1, 4), (4, 9), (0, 1), (3, 7)],
            [(4, 9), (1, 3), (3, 8), (2, 6), (1, 4), (4, 9), (0, 1), (3, 7)],
            [(4, 9), (3, 8), (1, 3), (2, 6), (1, 4), (4, 9), (0, 1), (3, 7)],
            [(4, 9), (3, 8), (2, 6), (1, 3), (1, 4), (4, 9), (0, 1), (3, 7)],
            [(4, 9), (3, 8), (2, 6), (1, 4), (1, 3), (4, 9), (0, 1), (3, 7)],
            [(4, 9), (3, 8), (2, 6), (1, 4), (4, 9), (1, 3), (0, 1), (3, 7)]
            ]
        
        similarities = []
        for s in swaps_illegal:
            similarities.append(m.lcs_similarity_delayed_recursion(C_swaps, s))
        self.assertEqual(similarities, [0] * len(swaps_illegal))     
        

    def test_Correct_NoRecursion(self):
        """Correct loop, no-recursion"""

        #              14                      14                      14     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       17         13           17        (13)          (17)       11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 12  11     15       10  12 (11)    15      (10) 12  13      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (10)             19  18  16              19  18  16
        #
        #             (14)                     10     
        #        ┌──────┴───┐            ┌──────┴───┐  
        #      (10)        11           14         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15       17  12  13     15       17  12  13      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘S_swaps
        # 19  18  16              19  18  16
        #

        input = [14, 17, 13, 15, 16, 12, 11, 19, 18, 10]
        swaps = [(4, 9), (2, 6), (1, 4), (0, 1)] # heap array indices
        m = self.__class__.matcher
        main_loop = m.loop_variants[0][2] # Correct
        heapify = m.no_recursion          # No-Recursion
        
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        
        self.assertListEqual(swaps, actual_swaps)

    def test_Correct_heapify_with_father_lr(self):
        """Correct loop, Heapify-with-Father LR"""

        #              17                      17                      17     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       14         13           14        (13)          14        (12)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   16      (16) 12  11     16       15 (12) 11     16       15  13 (11)      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (15)             19  18  16              19  18  16
        #
        #             (17)                    (14)                    11     
        #        ┌──────┴───┐            ┌──────┴───┐           ┌──────┴───┐  
        #      (14)        11           17        (11)         17         14
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐     ┌───┴────┐   ┌─┴─┐
        #   16       15  13  12     16       15  12  13    16       15  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘           ┌─┴─┐   ┌──┘
        # 19  18  16              19  18  16             19  18  16
        #
        
        input = [17, 14, 13, 16, 16, 12, 11, 19, 18, 15]
        swaps = [(4, 9), (2, 5), (2, 6), (0, 1), (0, 2)] # heap array
        
        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        heapify = m.heapify_with_father_lr # Heapify-with-Father LR
        
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        
        self.assertListEqual(swaps, actual_swaps)
        
    def test_Correct_heapify_with_father_lr_recursive(self):
        """Correct loop, Heapify-with-Father LR recursive"""

        #              17                      17                      17     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       14         13           14        (13)          14        (12)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   16      (16) 12  11     16       15 (12) 11     16       15  13 (11)      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (15)             19  18  16              19  18  16
        #
        #             (17)                     14                     14     
        #        ┌──────┴───┐            ┌──────┴───┐           ┌──────┴───┐  
        #      (14)        11          (17)        11         (16)        11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐     ┌───┴────┐   ┌─┴─┐
        #   16       15  13  12    (16)      15  13  12    17      (15) 13  12 
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘           ┌─┴─┐   ┌──┘
        # 19  18  16              19  18  16             19  18  16
        #
        #             (14)                     11                     11     
        #        ┌──────┴───┐            ┌──────┴───┐           ┌──────┴───┐  
        #       15        (11)          15        (14)         15        (13)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐     ┌───┴────┐   ┌─┴─┐
        #   17       16  13  12     17       16 (13) 12    17       16  14 (12)
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘           ┌─┴─┐   ┌──┘
        # 19  18  16              19  18  16             19  18  16
        #
        #              11     
        #        ┌──────┴───┐  
        #       15         12
        #    ┌───┴────┐   ┌─┴─┐
        #   17       16  14  13
        #  ┌─┴─┐   ┌──┘
        # 19  18  16
                
        input = [17, 14, 13, 16, 16, 12, 11, 19, 18, 15]
        swaps = [(4, 9), (2, 5), (2, 6), (0, 1), (1,3), (1,4), (0, 2), (2, 5),
                 (2, 6)] # heap array
        
        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        heapify = m.heapify_with_father_lr_recursive # Heapify-with-Father LR
        
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        
        self.assertListEqual(swaps, actual_swaps)


    def test_Correct_heapify_with_father_rl(self):
        """Correct loop, Heapify-with-Father RL"""

        #              14                      14                      14     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       17         13           17        (13)          17        (12)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 11  12     15       10  11 (12)    15       10 (11) 13      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (10)             19  18  16              19  18  16
        #
        #              14                     (14)                   (11)    
        #        ┌──────┴───┐            ┌──────┴───┐           ┌──────┴───┐  
        #      (17)        11           10        (11)        (10)        14
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐     ┌───┴────┐   ┌─┴─┐
        #   15      (10) 12  13     15       17  12  13    15       17  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘           ┌─┴─┐   ┌──┘
        # 19  18  16              19  18  16             19  18  16
        #
        #              10     
        #        ┌──────┴───┐  
        #       11         14
        #    ┌───┴────┐   ┌─┴─┐
        #   15       17  12  13
        #  ┌─┴─┐   ┌──┘
        # 19  18  16
        
        input = [14, 17, 13, 15, 16, 11, 12, 19, 18, 10]
        swaps = [(4, 9), (2, 6), (2, 5), (1, 4), (0, 2), (0, 1)] # heap array
        
        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        heapify = m.heapify_with_father_rl # Heapify-with-Father RL
        
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        
        self.assertListEqual(swaps, actual_swaps)

    def test_Correct_heapify_with_father_rl_recursive(self):
        """Correct loop, Heapify-with-Father RL"""

        #              14                      14                      14     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       17         13           17        (13)          17        (12)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 11  12     15       10  11 (12)    15       10 (11) 13      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  18 (10)             19  18  16              19  18  16
        #
        #              14                      14                    (14)    
        #        ┌──────┴───┐            ┌──────┴───┐           ┌──────┴───┐  
        #      (17)        11           10         11          10        (11)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐     ┌───┴────┐   ┌─┴─┐
        #   15      (10) 12  13     15      (17) 12  13    15       16  12  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘           ┌─┴─┐   ┌──┘
        # 19  18  16              19  18 (16)            19  18  17
        #
        #              11                      11                    (11)
        #        ┌──────┴───┐            ┌──────┴───┐           ┌──────┴───┐  
        #       10        (14)          10        (13)        (10)        12 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐     ┌───┴────┐   ┌─┴─┐
        #   15       16  12 (13)    15       16 (12) 14    15       16  14  13
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘           ┌─┴─┐   ┌──┘
        # 19  18  17              19  18  17             19  18  17
        #
        #              10
        #        ┌──────┴───┐  
        #       11         12 
        #    ┌───┴────┐   ┌─┴─┐
        #   15       16  14  13
        #  ┌─┴─┐   ┌──┘
        # 19  18  17
        
        
        
        input = [14, 17, 13, 15, 16, 11, 12, 19, 18, 10]
        swaps = [(4, 9), (2, 6), (2, 5), (1, 4), (4, 9), (0, 2), (2, 6),
                 (2, 5), (0, 1)]  # heap array indices
        
        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        heapify = m.heapify_with_father_rl_recursive
        
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        
        self.assertListEqual(swaps, actual_swaps)
            

    def test_Correct_heapify_up(self):
        """Correct loop, Heapify-Up"""

        #              14                      14                     (14)    
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       17         13          (17)        13          (12)        13
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 18  10     15      (12) 18  10     15       17  18  10      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  11 (12)             19  18  16              19  18  16
        #
        #              12                      12                     (12)    
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       14         13          (14)        13          (11)        13
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (15)      17  18  10    (11)      17  18  10     14       17  18  10 
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19 (11) 16              19  15  16              19  15  16
        #
        #              11                     (11)                     10     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       12        (13)          12        (10)          12         10
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   14       17  18 (10)    14       17  18  13     14       17  18  13 
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  15  16              19  15  16              19  15  16
        
        
        input = [14, 17, 13, 15, 16, 18, 10, 19, 11, 12]
        swaps = [(4, 9), (1, 4), (0, 1), (3, 8), (1, 3),  # heap array indices
                 (0, 1), (2, 6), (0, 2)]
        
        m = self.__class__.matcher
        main_loop = m.loop_variants[0][2]  # Correct
        heapify = m.heapify_up             # Heapify-Up
        
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        
        self.assertListEqual(swaps, actual_swaps)

    def test_Correct_max_heapify(self):
        """Correct loop, Max-Heapify"""

        #              10                      10                      10     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       12         11           12         11           12        (11)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (14) 16  13    (15)      18  16  10     19       18 (16) 13      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  17 (18)            (19) 17  14              15  17  14
        #
        #              10                      10                     (10)    
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #      (12)        16           19         16          (19)        16 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (19)      18  11  13    (12)      18  11  13     17       18  11  13      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 15  17  14              15 (17) 14              15  12  14
        #
        #              19                      19                      19     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #      (10)        16           18         16           18         16 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   17      (18) 11  13     17      (10) 11  13     17       14  11  13      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 15  12  14              15  12 (14)             15  12  10

        
        input = [10, 12, 11, 15, 14, 16, 13, 19, 17, 18]
        swaps = [(4, 9), (3, 7), (2, 5), (1, 3), (3, 8),  # heap array indices
                 (0, 1), (1, 4), (4, 9)]
        
        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        heapify = m.max_heapify        # Max-Heapify
        
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        
        self.assertListEqual(swaps, actual_swaps)

    def test_Correct_wrong_duplicate(self):
        """Correct loop, Wrong-duplicate"""

        #              19                      19                      19     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       13         16           13         16           13        (16)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (12) 11  10    (15)      10  11  10     10       10  11 (10)     
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 10  10 (10)             10 (10) 12              10  15  12
        #
        #              19                      19                     (19)    
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #      (13)        10           10         10           10        (10)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   10      (10) 11  16     10      (13) 11  16     10       10  11  16      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 10  15  12              10  15 (12)             10  15  13
        #
        #              10                      10    
        #        ┌──────┴───┐            ┌──────┴───┐  
        #       10        (19)          10         11
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   10       10 (11) 16     10       10  19  16      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 10  15  12              10  15  12

        
        input = [19, 13, 16, 15, 12, 11, 10, 10, 10, 10]
        swaps = [(4, 9), (3, 8), (2, 6), (1, 4),  # heap array indices
                 (4, 9), (0, 2), (2, 5)]
        
        m = self.__class__.matcher
        main_loop = [4, 3, 2, 1, 0]    # Correct
        heapify = m.wrong_duplicate       # Max-Heapify
        
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        
        self.assertListEqual(swaps, actual_swaps)
        
    def test_Correct_path_bubblesort(self):
        """Correct loop, Path-bubblesort"""

        #              14                      14                     (14)    
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       17         13          (17)        13          (12)        13 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 18  11     15      (12) 18  11     15       17  18  11      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  10 (12)             19  10  16              19  10  16
        #
        #
        #              12                      12                      12     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       14         13           14         13          (14)        13 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (17) 18  11    (15)      16  18  11    (10)      16  18  11     
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  10 (16)             19 (10) 17              19  15  17 
        #
        #             (12)                     10                      10
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #      (10)        13           12        (13)          12         11 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   14       16  18  11     14       16  18 (11)    14       16  18  13     
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  15  17              19  15  17              19  15  17                
        
        input = [14, 17, 13, 15, 16, 18, 11, 19, 10, 12]
        swaps = [(4, 9), (1, 4), (0, 1), (4, 9), (3, 8),  # heap array indices
                 (1, 3), (0, 1), (2, 6)]
        
        m = self.__class__.matcher
        main_loop = m.loop_variants[0][2]  # Correct
        heapify = m.path_bubblesort       # Path-Bubblesort
        
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        
        self.assertListEqual(swaps, actual_swaps)   
    
    #
    # Main loop variants
    #
    
    def test_Zigzag_RL(self):
        """Loop: Zigzag RL, correct Heapify"""

        #              14                      14                      14     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       17         13           17         13          (17)        13 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 18  11    (15)      12  18  11    (10)      12  18  11      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  10 (12)             19 (10) 16              19  15  16        
        #
        #              14                      14                     (14)    
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       10         13           10        (13)         (10)        11 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (17)      12  18  11     15       12  18 (11)    15       12  18  13      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19 (15) 16              19  17  16              19  17  16
        #
        #              10                      14    
        #        ┌──────┴───┐            ┌──────┴───┐  
        #      (14)        11           12         11 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (12) 18  13     15       14  18  13      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  17  16              19  17  16
        
        input = [14, 17, 13, 15, 16, 18, 11, 19, 10, 12]
        swaps = [(4, 9), (3, 8), (1, 3), (3, 8), (2, 6),  # heap array indices
                 (0, 1), (1, 4)]
         
        m = self.__class__.matcher
        main_loop = m.loop_variants[1][2]  # Zigzag RL
        heapify = m.min_heapify            # Correct heapify
         
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        
        self.assertListEqual(swaps, actual_swaps)

    def test_Zigzag_LR(self):
        """Loop: Zigzag LR, correct Heapify"""

        #              14                      14                      14     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       17         13           17         13           17        (13)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (15)      16  18  11     10      (16) 18  11     10       12  18 (11)     
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19 (10) 12              19  15 (12)             19  15  16        
        #
        #              14                      14                     (14)    
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #      (17)        11           10         11          (10)        11 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (10)      12  18  13    (17)      12  18  13     15       12  18  13     
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  15  16              19 (15) 16              19  17  16        
        #
        #              10                      10     
        #        ┌──────┴───┐            ┌──────┴───┐  
        #      (14)        11           12         11 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (12) 18  13     15       14  18  13     
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  17  16              19  17  16        
        
        input = [14, 17, 13, 15, 16, 18, 11, 19, 10, 12]
        swaps = [(3, 8), (4, 9), (2, 6), (1, 3), (3, 8),  # heap array indices
                 (0, 1), (1, 4)]
         
        m = self.__class__.matcher
        main_loop = m.loop_variants[2][2]  # Zigzag LR
        heapify = m.min_heapify            # Correct heapify
         
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        
        self.assertListEqual(swaps, actual_swaps) 
    
    def test_Level_LR(self):
        """Loop: Level LR, correct Heapify"""

        #              14                      14                      14     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       17         13           17         13          (17)        13 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (15)      16  18  11     10      (16) 18  11    (10)      12  18  11      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19 (10) 12              19  15 (12)             19  15  16        
        #
        #              14                      14                     (14)    
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       10         13           10        (13)         (10)        11 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (17)      12  18  11     15       12  18 (11)    15       12  18  13     
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19 (15) 16              19  17  16              19  17  16        
        #
        #              10                      10     
        #        ┌──────┴───┐            ┌──────┴───┐  
        #      (14)        11           12         11 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (12) 18  13     15       14  18  13     
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 19  17  16              19  17  16        
        
        input = [14, 17, 13, 15, 16, 18, 11, 19, 10, 12]
        swaps = [(3, 8), (4, 9), (1, 3), (3, 8), (2, 6),  # heap array indices
                 (0, 1), (1, 4)]
         
        m = self.__class__.matcher
        main_loop = m.loop_variants[3][2]  # Zigzag LR
        heapify = m.min_heapify            # Correct heapify
         
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)
        
        self.assertListEqual(swaps, actual_swaps) 

    def test_Top_down(self):
        """Loop: Top-down, correct Heapify"""

        # It is not possible to produce an input which would make heapify
        # act on each index. This first input causes heapify to swap elements
        # at main loop indices 0, 1, 2, and 4.

        #             (19)                     17                      17     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #      (17)        18          (19)        18           15         18 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15       16  13  14    (15)      16  13  14    (19)      16  13  14      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  10  12              11  10  12              11 (10) 12        
        #
        #              17                      17                    17           
        #        ┌──────┴───┐            ┌──────┴───┐          ┌──────┴───┐      
        #      (15)        18           10         18         10        (18)    
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐    ┌───┴────┐   ┌─┴─┐
        #  (10)      16  13  14    (15)      16  13  14   11       16 (13) 14      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘          ┌─┴─┐   ┌──┘
        # 11  19  12             (11) 19  12            15  19  12
        #
        #              17                      17     
        #        ┌──────┴───┐            ┌──────┴───┐  
        #       10         13           10         13 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   11      (16) 18  14     11       12  18  14      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 15  19 (12)             15  19  16        
        
        input = [19, 17, 18, 15, 16, 13, 14, 11, 10, 12]
        swaps = [(0, 1), (1, 3), (3, 8), (1, 3), (3, 7),  # heap array indices
                 (2, 5), (4, 9)]
         
        m = self.__class__.matcher
        main_loop = m.loop_variants[4][2]  # Top-down
        heapify = m.min_heapify            # Correct heapify
         
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)        
        self.assertListEqual(swaps, actual_swaps) 

        # This second input causes heapify to swap elements at main loop indices
        # 0, 2, 3, 4.
        #
        #             (19)                     17                      17     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #      (17)        18           19        (18)          19         13 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   20       21  13  14     20       21 (13) 14    (20)      21  18  14      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  10  12              11  10  12              11 (10) 12        
        #
        #              17                      17           
        #        ┌──────┴───┐            ┌──────┴───┐      
        #       19         13           19         13    
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   10      (21) 18  14     10       12  18  14      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  20 (12)             11  20  21
         
        input = [19, 17, 18, 20, 21, 13, 14, 11, 10, 12]
        swaps = [(0, 1), (2, 5), (3, 8), (4, 9)]  # heap array indices
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)        
        self.assertListEqual(swaps, actual_swaps) 

    def test_Zigzag_Top_down_LR(self):
        """Loop: Zigzag Top-down LR, No-Recursion"""

        # No-Recursion heapify is used here to make testing of the zigzag
        # iteration easier.
        # 
        #             (11)                     10                      10     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       15        (10)         (15)        11           12        (11)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   12       16   3   4    (12)      16   3   4     15       16  (3)  4      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  10   9              11  10   9              11  10   9
        # 
        #              10                      10                      10     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       12          3           12          3           12          3 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 11   4    (15)       9  11   4     10        9  11   4      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  10  (9)             11 (10) 16              11  15  16        

        input = [11, 15, 10, 12, 16, 3, 4, 11, 10, 9]
        swaps = [(0, 2), (1, 3), (2, 5), (4, 9), (3, 8)] # heap array indices
         
        m = self.__class__.matcher
        main_loop = m.loop_variants[5][2] 
        heapify = m.no_recursion          
         
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)        
        self.assertListEqual(swaps, actual_swaps) 
            
    def test_Zigzag_Top_down_RL(self):
        """Loop: Zigzag Top-down RL, No-Recursion"""

        # No-Recursion heapify is used here to make testing of the zigzag
        # iteration easier.
        # 
        #             (11)                     10                      10     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       15        (10)          15        (11)         (15)         3 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   12       16   3   4     12       16  (3)  4    (12)      16  11   4      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  10   9              11  10   9              11  10   9
        # 
        #              10                      10                      10     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       12          3           12          3           12          3 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15      (16) 11   4    (15)       9  11   4     10        9  11   4      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  10  (9)             11 (10) 16              11  15  16        

        input = [11, 15, 10, 12, 16, 3, 4, 11, 10, 9]
        swaps = [(0, 2), (2, 5), (1, 3), (4, 9), (3, 8)] # heap array indices
         
        m = self.__class__.matcher
        main_loop = m.loop_variants[6][2] 
        heapify = m.no_recursion          
         
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)        
        self.assertListEqual(swaps, actual_swaps) 

    def test_inorder(self):
        """Loop: Inorder, No-Recursion"""

        # No-Recursion heapify is used here to make testing easier.
        # 
        #              13                      13                      13     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       15         10          (15)        10           10         10 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (12)      19   3   4    (10)      19   3   4     15      (19)  3   4      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11 (10) 16              11  12  16              11  12 (16)
        #
        #             (13)                     10                      10     
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #      (10)        10           13        (10)          13          3 
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   15       16   3   4     15       16  (3)  4     15       16  10   4      
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  12  19              11  12  19              11  12  19 


        input = [13, 15, 10, 12, 19, 3, 4, 11, 10, 16]
        swaps = [(3, 8), (1, 3), (4, 9), (0, 1), (2, 5)] # heap array indices
         
        m = self.__class__.matcher
        main_loop = m.loop_variants[7][2] 
        heapify = m.no_recursion          
         
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)        
        self.assertListEqual(swaps, actual_swaps) 

    def test_subtree_min_index(self):
        """Tests searching a minimun index in a subtree of a binary heap."""
        
        #              13     
        #        ┌──────┴───┐  
        #       15         10 
        #    ┌───┴────┐   ┌─┴─┐
        #   12       19   3   4      
        #  ┌─┴─┐   ┌──┘
        # 11  14  16
        
        input = [13, 15, 10, 12, 19, 3, 4, 11, 14, 16]   
        expected_min_values = [3, 11, 3, 11, 16, 3, 4, 11, 14, 16]
        m = self.__class__.matcher
        
        computed_min_values = []
        for i in range(10):
            min_value = 100
            min_index = -1
            (min_value, min_index) = m.subtree_min_index(input, i, min_value,
                min_index)
            computed_min_values.append(min_value)
            
        self.assertListEqual(expected_min_values, computed_min_values)
        
        #              10     
        #        ┌──────┴───┐  
        #       12         11 
        #    ┌───┴────┐   ┌─┴─┐
        #   15       16  13  14      
        #  ┌─┴─┐   ┌──┘
        # 18  17  19
        input = [10, 12, 11, 15, 16, 13, 14, 18, 17, 16] 
        expected_min_values = input
        
        computed_min_values = []
        for i in range(10):
            min_value = 100
            min_index = -1
            (min_value, min_index) = m.subtree_min_index(input, i, min_value,
                min_index)
            computed_min_values.append(min_value)
            
        self.assertListEqual(expected_min_values, computed_min_values)

     
    def test_smallest_instantly_up(self):
        """Tests Smallest-Instantly-Up heapify variant."""
                    
        #             (13)                      3                       3    
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐  
        #       15         10          (15)        10           11        (10)
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #   12       19  (3)  4     12       19  13   4     12       19  13  (4)
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 11  11  16             (11) 11  16              15  11  16
        #
        #               3                       3                       3
        #        ┌──────┴───┐            ┌──────┴───┐            ┌──────┴───┐
        #       11          4           11          4           11          4
        #    ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐      ┌───┴────┐   ┌─┴─┐
        #  (12)      19  13   4     11      (19) 13   4     11       16  13   4
        #  ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘            ┌─┴─┐   ┌──┘
        # 15 (11) 16              15  12 (16)             15  12  19
          
        input = [13, 15, 10, 12, 19, 3, 4, 11, 11, 16]
        expected_swaps = [(0, 5), (1, 7), (2, 6), (3, 8), (4, 9)]
        
        m = self.__class__.matcher
        main_loop = m.loop_variants[4][2]  # Top-down / level order
        heapify = m.smallest_instantly_up
         
        (states, actual_swaps) = m.build_heap_variant(main_loop, heapify, input)        
        self.assertListEqual(expected_swaps, actual_swaps)                      

class TestDTW(unittest.TestCase):
    
    def print_array(self, A, w, h):
        s = ""
        for i in range(h):            
            for j in range(w):
                s += "{:2.0f} ".format(A[i * w + j])
            s += "\n"
        print(s)
    
    def d(self, x, y):
        return abs(x - y)
    
    def test_zero(self):
        """If one of sequences has zero length, dtw is zero."""
        X = []
        Y = [1, 2]
        self.assertEqual(dtw(X, Y, self.d), 0)
        self.assertEqual(dtw(Y, X, self.d), 0)
        
    def test_identity(self):
        """dtw(x,x) == 0"""
        X = [1, 3, 2, 4]
        self.assertEqual(dtw(X, X, self.d), 0)
        
    def test_symmetricity(self):
        X = [1, 3, 2, 4]
        Y = [1, 5, 3, 8]
        d1 = dtw(X, Y, self.d)
        d2 = dtw(Y, X, self.d)
        self.assertTrue(d1 > 0)
        self.assertTrue(d2 > 0)
        self.assertEqual(d1, d2)
    
    def test_array(self):
        """Pen and paper worked example"""        
        
        X = [0, 4, 3, 1, 4, 3, 2, 0]
        Y = [0, 4, 2, 0, 4, 2, 0, 4, 2]
        
        expected_g = [ 0,  4,  7,  8, 12, 15, 17, 17,
                       4,  0,  1,  4,  4,  5,  7, 11,
                       6,  2,  2,  3,  5,  6,  5,  7,
                       6,  6,  5,  4,  8,  9,  7,  5,
                      10,  6,  6,  7,  4,  5,  7,  9,
                      12,  8,  7,  8,  6,  6,  5,  7,
                      12, 12, 10,  9, 10,  9,  7,  5,
                      16, 12, 11, 12,  9, 10,  9,  9,
                      18, 14, 12, 13, 11, 11,  9, 11]
        
        g = dtw(X, Y, self.d, return_array = True)
        #self.print_array(g, len(X), len(Y))

        self.assertEqual(len(g), len(expected_g),
            "Size of dynamic programming array differs from expected.")
        
        msg = "Dynamic programming array at index {} differs from expected."
        for i in range(len(expected_g)):
            
            self.assertAlmostEqual(g[i], expected_g[i],
                msg = (msg.format(i)))
        
                    
if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()